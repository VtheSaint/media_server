# Проект Media Stream Recorder

## Оглавление
1. [Routes](#routes)
2. [Messages](#messages)
3. [Storage](#storage)
4. [Tasks](#tasks)
5. [Запуск](#запуск)


## Routes
В данном разделе описан единственный маршрут, предназначенный для установки WebSocket-соединения.

### Маршрут для установки WebSocket-соединения
- **Описание:** Этот маршрут предоставляет возможность установки WebSocket-соединения для взаимодействия с клиентами.
- **Путь:** `/{room_id}/{session_id}`
- **Метод:** GET
- **Параметры:**
  - `{room_id}`: Уникальный идентификатор комнаты/чата.
  - `{session_id}`: Уникальный идентификатор сессии/подключения.
- **Действие:** Маршрут создает новое WebSocket-соединение (`WsConn`) и запускает его, используя предоставленные параметры.
- **Пример использования:**
  ```bash
  ws://your_server_address/your_room_id/your_session_id


## Messages
В данном разделе определены различные типы сообщений (Messages), используемые в приложении для обмена информацией между актерами (actors) в рамках фреймворка Actix и работы с WebSocket.

### WsMessage
- **Описание:** Простое текстовое сообщение для передачи через WebSocket.
- **Результат:** `()` (пустой тип).

### Connect
- **Описание:** Сообщение, отправляемое при подключении нового пользователя к WebSocket.
- **Поля:**
    - `addr`: Адрес получателя (Recipient) для отправки сообщений.
    - `self_id`: Уникальный идентификатор пользователя.
    - `room_id`: Уникальный идентификатор комнаты/чата.
- **Результат:** `()` (пустой тип).

### Disconnect
- **Описание:** Сообщение, отправляемое при отключении пользователя от WebSocket.
- **Поля:**
    - `self_id`: Уникальный идентификатор пользователя.
    - `room_id`: Уникальный идентификатор комнаты/чата.
- **Результат:** `()` (пустой тип).

### AudioFrame
- **Описание:** Сообщение, представляющее аудиофрейм для передачи по сети.
- **Поля:**
    - `j_type`: Тип сообщения (JSON тип).
    - `storage_id`: Уникальный идентификатор хранилища аудиофайлов.
    - `body`: Содержание аудиофрейма в виде байтов.
    - `part`: Номер части аудиофрейма (если файл разделен на части).
- **Результат:** `()` (пустой тип).

### VideoFrame
- **Описание:** Сообщение, представляющее видеофрейм для передачи по сети.
- **Поля:**
    - `j_type`: Тип сообщения (JSON тип).
    - `storage_id`: Уникальный идентификатор хранилища видеофайлов.
    - `body`: Содержание видеофрейма в виде байтов.
    - `part`: Номер части видеофрейма (если файл разделен на части).
- **Результат:** `()` (пустой тип).


## Storage
В данном разделе хранятся медиафайлы, записанные в течение всей сессии. Каждый файл идентифицируется по имени файла, которое соответствует полю `self_id` в теле запроса Connect.

### Описание
Данная папка предназначена для хранения аудио- и видеофайлов, записанных в процессе взаимодействия с приложением. Идентификация файлов осуществляется по уникальному идентификатору пользователя (`self_id`), который указывается в теле запроса Connect при подключении пользователя.

### Идентификация файлов
Имя каждого файла включает в себя уникальный идентификатор пользователя (`self_id`), который гарантирует уникальность файла в рамках всей системы. Например, если пользователь с `self_id` равным "user1_uuid" записывает аудиофайл, то имя файла будет "user1_uuid.mp3" и он будет доступен для последующего воспроизведения или обработки.


## Tasks
В данном разделе описаны задачи, выполняемые сервером после завершения сессии. Сервер проверяет наличие записанных файлов из mediaStream, и при наличии последних добавляет новое задание (файл) с именем по типу `${self_id}`.

### Описание
После завершения сессии сервер производит проверку наличия записанных медиафайлов, полученных от клиентов через mediaStream. В случае обнаружения таких файлов, сервер добавляет новое задание (файл) в систему с именем, сгенерированным на основе уникального идентификатора пользователя (`self_id`).

### Процесс
1. **Завершение сессии:**
   - После завершения сессии клиента сервер инициирует проверку наличия записанных медиафайлов.

2. **Проверка наличия файлов:**
   - Сервер проверяет наличие медиафайлов, записанных в течение сессии, в хранилище.

3. **Добавление задания:**
   - При обнаружении файлов сервер добавляет новое задание (файл) в систему для дальнейшей обработки.
   - Имя файла генерируется на основе уникального идентификатора пользователя (`self_id`). Например, имя файла может быть `${self_id}.task`.


## Запуск
Для запуска проекта выполните следующие шаги:

1. **Установка зависимостей:**
    ```bash
    cargo build
    ```

2. **Запуск проекта:**
    ```bash
    cargo run
    ```

    Эта команда запустит ваше приложение. Убедитесь, что все зависимости установлены перед запуском.

3. **Тестирование:**
    ```bash
    cargo test
    ```

    Проверьте работоспособность проекта с помощью ваших тестов.

4. **Проверка в браузере:**
   - Откройте ваш веб-браузер и перейдите по адресу [http://localhost:your_port](http://localhost:your_port), где `your_port` - порт, на котором запущено ваше приложение.

### Примечание
Убедитесь, что у вас установлен [Rust](https://www.rust-lang.org/tools/install) и [Cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html) перед выполнением этих команд.

